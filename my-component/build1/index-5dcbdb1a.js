const NAMESPACE="my-component";let scopeId,hostTagName,queuePending=!1;const win="undefined"!=typeof window?window:{},doc=win.document||{head:{}},plt={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,s,n)=>e.addEventListener(t,s,n),rel:(e,t,s,n)=>e.removeEventListener(t,s,n),ce:(e,t)=>new CustomEvent(e,t)},promiseResolve=e=>Promise.resolve(e),supportsConstructibleStylesheets=(()=>{try{return new CSSStyleSheet,!0}catch(e){}return!1})(),HYDRATED_CSS="{visibility:hidden}.hydrated{visibility:inherit}",createTime=(e,t="")=>()=>{},uniqueTime=(e,t)=>()=>{},rootAppliedStyles=new WeakMap,registerStyle=(e,t,s)=>{let n=styles.get(e);supportsConstructibleStylesheets&&s?(n=n||new CSSStyleSheet).replace(t):n=t,styles.set(e,n)},addStyle=(e,t,s,n)=>{let o=getScopeId(t),l=styles.get(o);if(e=11===e.nodeType?e:doc,l)if("string"==typeof l){e=e.head||e;let t,s=rootAppliedStyles.get(e);s||rootAppliedStyles.set(e,s=new Set),s.has(o)||((t=doc.createElement("style")).innerHTML=l,e.insertBefore(t,e.querySelector("link")),s&&s.add(o))}else e.adoptedStyleSheets.includes(l)||(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return o},attachStyles=e=>{const t=e.$cmpMeta$,s=e.$hostElement$,n=t.$flags$,o=(t.$tagName$,()=>{}),l=addStyle(s.shadowRoot?s.shadowRoot:s.getRootNode(),t);10&n&&(s["s-sc"]=l,s.classList.add(l+"-h")),o()},getScopeId=(e,t)=>"sc-"+e.$tagName$,isDef=e=>null!=e,isComplexType=e=>"object"===(e=typeof e)||"function"===e,h=(e,t,...s)=>{let n=null,o=!1,l=!1,a=[];const $=t=>{for(let s=0;s<t.length;s++)n=t[s],Array.isArray(n)?$(n):null!=n&&"boolean"!=typeof n&&((o="function"!=typeof e&&!isComplexType(n))&&(n=String(n)),o&&l?a[a.length-1].$text$+=n:a.push(o?newVNode(null,n):n),l=o)};$(s);const r=newVNode(e,null);return r.$attrs$=t,a.length>0&&(r.$children$=a),r},newVNode=(e,t)=>{return{$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null}},Host={},isHost=e=>e&&e.$tag$===Host,createElm=(e,t,s,n)=>{let o,l,a=t.$children$[s],$=0;if(null!==a.$text$)o=a.$elm$=doc.createTextNode(a.$text$);else if(o=a.$elm$=doc.createElement(a.$tag$),isDef(scopeId)&&o["s-si"]!==scopeId&&o.classList.add(o["s-si"]=scopeId),a.$children$)for($=0;$<a.$children$.length;++$)(l=createElm(e,a,$))&&o.appendChild(l);return o},addVnodes=(e,t,s,n,o,l)=>{let a,$=e;for($.shadowRoot&&$.tagName===hostTagName&&($=$.shadowRoot);o<=l;++o)n[o]&&(a=createElm(null,s,o))&&(n[o].$elm$=a,$.insertBefore(a,t))},removeVnodes=(e,t,s,n,o)=>{for(;t<=s;++t)(n=e[t])&&n.$elm$.remove()},updateChildren=(e,t,s,n)=>{let o,l=0,a=0,$=t.length-1,r=t[0],d=t[$],c=n.length-1,i=n[0],p=n[c];for(;l<=$&&a<=c;)null==r?r=t[++l]:null==d?d=t[--$]:null==i?i=n[++a]:null==p?p=n[--c]:isSameVnode(r,i)?(patch(r,i),r=t[++l],i=n[++a]):isSameVnode(d,p)?(patch(d,p),d=t[--$],p=n[--c]):isSameVnode(r,p)?(patch(r,p),e.insertBefore(r.$elm$,d.$elm$.nextSibling),r=t[++l],p=n[--c]):isSameVnode(d,i)?(patch(d,i),e.insertBefore(d.$elm$,r.$elm$),d=t[--$],i=n[++a]):(o=createElm(t&&t[a],s,a),i=n[++a],o&&r.$elm$.parentNode.insertBefore(o,r.$elm$));l>$?addVnodes(e,null==n[c+1]?null:n[c+1].$elm$,s,n,a,c):a>c&&removeVnodes(t,l,$)},isSameVnode=(e,t)=>e.$tag$===t.$tag$,patch=(e,t)=>{const s=t.$elm$=e.$elm$,n=e.$children$,o=t.$children$,l=t.$text$;null===l?null!==n&&null!==o?updateChildren(s,n,t,o):null!==o?(null!==e.$text$&&(s.textContent=""),addVnodes(s,null,t,o,0,o.length-1)):null!==n&&removeVnodes(n,0,n.length-1):e.$text$!==l&&(s.data=l)},renderVdom=(e,t)=>{const s=e.$hostElement$,n=e.$vnode$||newVNode(null,null),o=isHost(t)?t:h(null,null,t);hostTagName=s.tagName,o.$tag$=null,o.$flags$|=4,e.$vnode$=o,o.$elm$=n.$elm$=s.shadowRoot||s,scopeId=s["s-sc"],patch(n,o)},emitEvent=(e,t,s)=>{const n=plt.ce(t,s);return e.dispatchEvent(n),n},attachToAncestor=(e,t)=>{t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise(t=>e.$onRenderResolve$=t))},scheduleUpdate=(e,t)=>{if(e.$flags$|=16,4&e.$flags$)return void(e.$flags$|=512);attachToAncestor(e,e.$ancestorComponent$);return writeTask(()=>dispatchHooks(e,t))},dispatchHooks=(e,t)=>{const s=(e.$cmpMeta$.$tagName$,()=>{}),n=e.$lazyInstance$;return s(),then(void 0,()=>updateComponent(e,n,t))},updateComponent=async(e,t,s)=>{const n=e.$hostElement$,o=(e.$cmpMeta$.$tagName$,()=>{}),l=n["s-rc"];s&&attachStyles(e);const a=(e.$cmpMeta$.$tagName$,()=>{});renderVdom(e,callRender(e,t)),l&&(l.map(e=>e()),n["s-rc"]=void 0),a(),o();{const t=n["s-p"],s=()=>postUpdateComponent(e);0===t.length?s():(Promise.all(t).then(s),e.$flags$|=4,t.length=0)}},callRender=(e,t)=>{try{t=t.render(),e.$flags$&=-17,e.$flags$|=2}catch(t){consoleError(t,e.$hostElement$)}return t},postUpdateComponent=e=>{e.$cmpMeta$.$tagName$;const t=e.$hostElement$,s=()=>{},n=e.$ancestorComponent$;64&e.$flags$?s():(e.$flags$|=64,addHydratedFlag(t),s(),e.$onReadyResolve$(t),n||appDidLoad()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),512&e.$flags$&&nextTick(()=>scheduleUpdate(e,!1)),e.$flags$&=-517},appDidLoad=e=>{addHydratedFlag(doc.documentElement),nextTick(()=>emitEvent(win,"appload",{detail:{namespace:NAMESPACE}}))},then=(e,t)=>e&&e.then?e.then(t):t(),addHydratedFlag=e=>e.classList.add("hydrated"),parsePropertyValue=(e,t)=>null==e||isComplexType(e)?e:1&t?String(e):e,getValue=(e,t)=>getHostRef(e).$instanceValues$.get(t),setValue=(e,t,s,n)=>{const o=getHostRef(e),l=o.$instanceValues$.get(t),a=o.$flags$,$=o.$lazyInstance$;s=parsePropertyValue(s,n.$members$[t][0]),8&a&&void 0!==l||s===l||(o.$instanceValues$.set(t,s),$&&2==(18&a)&&scheduleUpdate(o,!1))},proxyComponent=(e,t,s)=>{if(t.$members$){const n=Object.entries(t.$members$),o=e.prototype;if(n.map(([e,[n]])=>{(31&n||2&s&&32&n)&&Object.defineProperty(o,e,{get(){return getValue(this,e)},set(s){setValue(this,e,s,t)},configurable:!0,enumerable:!0})}),1&s){const t=new Map;o.attributeChangedCallback=function(e,s,n){plt.jmp(()=>{const s=t.get(e);this[s]=(null!==n||"boolean"!=typeof this[s])&&n})},e.observedAttributes=n.filter(([e,t])=>15&t[0]).map(([e,s])=>{const n=s[1]||e;return t.set(n,e),n})}}return e},initializeComponent=async(e,t,s,n,o)=>{if(0==(32&t.$flags$)){{if(t.$flags$|=32,(o=loadModule(s)).then){const e=()=>{};o=await o,e()}o.isProxied||(proxyComponent(o,s,2),o.isProxied=!0);const e=(s.$tagName$,()=>{});t.$flags$|=8;try{new o(t)}catch(e){consoleError(e)}t.$flags$&=-9,e()}if(o.style){let e=o.style;const t=getScopeId(s);if(!styles.has(t)){const n=(s.$tagName$,()=>{});registerStyle(t,e,!!(1&s.$flags$)),n()}}}const l=t.$ancestorComponent$,a=()=>scheduleUpdate(t,!0);l&&l["s-rc"]?l["s-rc"].push(a):a()},connectedCallback=e=>{if(0==(1&plt.$flags$)){const t=getHostRef(e),s=t.$cmpMeta$,n=(s.$tagName$,()=>{});if(!(1&t.$flags$)){t.$flags$|=1;{let s=e;for(;s=s.parentNode||s.host;)if(s["s-p"]){attachToAncestor(t,t.$ancestorComponent$=s);break}}s.$members$&&Object.entries(s.$members$).map(([t,[s]])=>{if(31&s&&e.hasOwnProperty(t)){const s=e[t];delete e[t],e[t]=s}}),initializeComponent(0,t,s)}n()}},disconnectedCallback=e=>{if(0==(1&plt.$flags$)){getHostRef(e)}},bootstrapLazy=(e,t={})=>{const s=()=>{},n=[],o=t.exclude||[],l=win.customElements,a=doc.head,$=a.querySelector("meta[charset]"),r=doc.createElement("style"),d=[];let c,i=!0;Object.assign(plt,t),plt.$resourcesUrl$=new URL(t.resourcesUrl||"./",doc.baseURI).href,e.map(e=>e[1].map(t=>{const s={$flags$:t[0],$tagName$:t[1],$members$:t[2],$listeners$:t[3]};s.$members$=t[2];const a=s.$tagName$,$=class extends HTMLElement{constructor(e){super(e),registerHost(e=this,s),1&s.$flags$&&e.attachShadow({mode:"open"})}connectedCallback(){c&&(clearTimeout(c),c=null),i?d.push(this):plt.jmp(()=>connectedCallback(this))}disconnectedCallback(){plt.jmp(()=>disconnectedCallback(this))}componentOnReady(){return getHostRef(this).$onReadyPromise$}};s.$lazyBundleId$=e[0],o.includes(a)||l.get(a)||(n.push(a),l.define(a,proxyComponent($,s,1)))})),r.innerHTML=n+HYDRATED_CSS,r.setAttribute("data-styles",""),a.insertBefore(r,$?$.nextSibling:a.firstChild),i=!1,d.length?d.map(e=>e.connectedCallback()):plt.jmp(()=>c=setTimeout(appDidLoad,30)),s()},hostRefs=new WeakMap,getHostRef=e=>hostRefs.get(e),registerInstance=(e,t)=>hostRefs.set(t.$lazyInstance$=e,t),registerHost=(e,t)=>{const s={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return s.$onReadyPromise$=new Promise(e=>s.$onReadyResolve$=e),e["s-p"]=[],e["s-rc"]=[],hostRefs.set(e,s)},consoleError=(e,t)=>(0,console.error)(e,t),cmpModules=new Map,loadModule=(e,t,s)=>{const n=e.$tagName$.replace(/-/g,"_"),o=e.$lazyBundleId$,l=cmpModules.get(o);return l?l[n]:import(`./${o}.entry.js`).then(e=>(cmpModules.set(o,e),e[n]),consoleError)},styles=new Map,queueDomReads=[],queueDomWrites=[],queueTask=(e,t)=>s=>{e.push(s),queuePending||(queuePending=!0,t&&4&plt.$flags$?nextTick(flush):plt.raf(flush))},consume=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(e){consoleError(e)}e.length=0},flush=()=>{consume(queueDomReads),consume(queueDomWrites),(queuePending=queueDomReads.length>0)&&plt.raf(flush)},nextTick=e=>promiseResolve().then(e),writeTask=queueTask(queueDomWrites,!0);export{bootstrapLazy as b,h,promiseResolve as p,registerInstance as r};
